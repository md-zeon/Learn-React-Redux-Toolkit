# React Redux Toolkit — Core Concepts

A practical tour of Redux Toolkit (RTK) fundamentals: architecture, APIs, patterns, and the why behind them. Skim-friendly with minimal code to apply fast.

See also:

- 02.Redux Toolkit setup and configuration.md
- 03.Advanced Redux Toolkit Concepts.md
- 4.  Summery.md
- 5.  Common Interview Questions and Answers.md

---

## 1) Why Redux Toolkit

- Less boilerplate than classic Redux; strong defaults (DevTools, middleware).
- Immer allows concise immutable updates.
- Opinionated APIs: `configureStore`, `createSlice`, `createAsyncThunk`, Entity Adapter, RTK Query (optional).
- First-class TypeScript support.

---

## 2) Architecture Fundamentals

- Store: single state container created with `configureStore`.
- State: serializable tree; represents app data at a point in time.
- Actions: plain objects describing events (`type`, optional `payload`).
- Reducers: pure functions computing next state from current state + action.
- Selectors: functions that read/derive data from state; can be memoized.

```js
import { configureStore } from "@reduxjs/toolkit";
import someReducer from "./features/some/slice";

export const store = configureStore({
	reducer: { some: someReducer },
});
```

---

## 3) Slices (createSlice)

- Bundle reducer logic and auto-generate action creators.
- Case reducers can “mutate” state safely via Immer.

```js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
	name: "counter",
	initialState: { value: 0 },
	reducers: {
		increment: (s) => {
			s.value += 1;
		},
		addBy: (s, a) => {
			s.value += a.payload;
		},
	},
});

export const { increment, addBy } = counterSlice.actions;
export default counterSlice.reducer;
```

Use in React:

```jsx
import { useSelector, useDispatch } from "react-redux";
import { increment, addBy } from "./features/counter/counterSlice";

const value = useSelector((s) => s.counter.value);
const dispatch = useDispatch();
```

---

## 4) Immutability via Immer

- Write mutable-looking updates; Immer produces immutable copies.
- Benefits: readability, fewer mistakes, structural sharing for performance.
- Keep state serializable (no class instances, DOM nodes, Promises, Dates are okay if handled carefully).

---

## 5) Selectors and Memoization

- Simple selector: `(state) => state.slice.key`.
- Memoized selectors with Reselect’s `createSelector` to avoid recomputes and re-renders.

```js
import { createSelector } from "reselect";

const selectItems = (s) => s.cart.items;
export const selectTotal = createSelector([selectItems], (items) =>
	items.reduce((sum, i) => sum + i.price * i.qty, 0),
);
```

Tips:

- Keep selectors narrow to reduce re-renders.
- Co-locate selectors with slice when possible.

---

## 6) Async Thunks (createAsyncThunk)

- Encapsulate async logic; dispatches `pending / fulfilled / rejected`.

```js
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

export const fetchUser = createAsyncThunk("user/fetch", async (id) => {
	const res = await fetch(`/api/users/${id}`);
	if (!res.ok) throw new Error("Network error");
	return res.json();
});

const userSlice = createSlice({
	name: "user",
	initialState: { data: null, status: "idle", error: null },
	reducers: {},
	extraReducers: (b) => {
		b.addCase(fetchUser.pending, (s) => {
			s.status = "loading";
		})
			.addCase(fetchUser.fulfilled, (s, a) => {
				s.status = "succeeded";
				s.data = a.payload;
			})
			.addCase(fetchUser.rejected, (s, a) => {
				s.status = "failed";
				s.error = a.error.message;
			});
	},
});
```

When to use:

- Client-side async that updates client state; simple data flows.
- For server state (fetching/caching), consider RTK Query.

---

## 7) Middleware

- Default middleware: thunk, serializable checks, immutability checks (dev).
- Add custom middleware for logging, analytics, feature flags, etc.

```js
const store = configureStore({
	reducer,
	middleware: (getDefault) => getDefault().concat(myMiddleware),
});
```

- Configure serializable checks when needed (e.g., ignoring specific paths).

---

## 8) Normalized State & Entity Adapter

- Normalize lists to `{ ids: [], entities: { id: entity } }` for efficient CRUD.
- `createEntityAdapter` provides reducers and selectors out of the box.

```js
import { createSlice, createEntityAdapter } from "@reduxjs/toolkit";

const usersAdapter = createEntityAdapter({ selectId: (u) => u.id });

const usersSlice = createSlice({
	name: "users",
	initialState: usersAdapter.getInitialState(),
	reducers: {
		upsertMany: usersAdapter.upsertMany,
		removeOne: usersAdapter.removeOne,
	},
});

export const usersSelectors = usersAdapter.getSelectors((s) => s.users);
```

---

## 9) RTK Query vs Client State

- RTK Query: server state (fetching, caching, invalidation, polling, optimistic updates, auto-generated hooks).
- Slices/Thunks: client state (UI state, local business logic, persisted preferences).
- Many data-fetching use cases are simpler with RTK Query.

---

## 10) Project Structure

- Feature-first folders: co-locate slice, selectors, async thunks, components, and tests.
- Example: `features/todos/{todosSlice.ts, selectors.ts, components/, tests/}`.
- Keep cross-cutting middleware and API services in dedicated layers.

---

## 11) DevTools and Built-in Checks

- Redux DevTools: inspect actions, time travel, state diffs.
- Serializable/immutability checks catch common mistakes during development.
- Configure checks via `configureStore` if you must ignore specific actions/paths.

---

## 12) TypeScript Essentials (Optional)

```ts
export const store = configureStore({ reducer });
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Typed hooks
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

- Prefer inference from `createSlice` and `configureStore`.
- Type payloads in `createAsyncThunk<TPayload, TArg>()`.

---

## 13) Best Practices & Anti-Patterns

Do:

- Normalize entities; keep state minimal; derive with selectors.
- Keep reducers pure; side effects in thunks/middleware.
- Split by feature; keep slices focused.
- Memoize expensive selectors; scope `useSelector` narrowly.

Avoid:

- Non-serializable state (functions, class instances, DOM nodes).
- Duplicating derived data in state.
- Monolithic mega-slices and global selectors for everything.

---

## 14) Quick Reference

- Setup store: `configureStore({ reducer: { feature: reducer } })`
- Create slice: `createSlice({ name, initialState, reducers })`
- Async: `createAsyncThunk(type, payloadCreator)` + `extraReducers(builder)`
- Selectors: `createSelector([inputs], projector)`
- Normalize: `createEntityAdapter()` + `adapter.getSelectors()`
- RTK Query: `createApi({ baseQuery, endpoints })`

---

## Next Steps

- Build a small feature using slices + selectors.
- Convert a fetch flow to RTK Query and compare complexity.
- Add Entity Adapter to any list-based state.

For deeper dives, see 02–05 in this repo.
