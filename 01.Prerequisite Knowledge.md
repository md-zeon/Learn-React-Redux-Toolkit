# Prerequisite Knowledge for React Redux Toolkit

## Overview

Before diving into Redux Toolkit, you should have a solid understanding of the following concepts. This document outlines the essential knowledge required to effectively learn and use Redux Toolkit.

---

## 1. JavaScript Fundamentals

### ES6+ Features

- **Arrow Functions**: `const add = (a, b) => a + b;`
- **Destructuring**: Extracting values from objects and arrays

  ```javascript
  const { name, age } = person;
  const [first, second] = array;
  ```

- **Spread Operator**: `...array` and `...object`
- **Template Literals**: Using backticks for string interpolation
- **Promises and Async/Await**: Handling asynchronous operations
- **Modules**: Import/Export syntax

### Object and Array Methods

- Array methods: `map()`, `filter()`, `reduce()`, `find()`
- Object methods: `Object.keys()`, `Object.values()`, `Object.entries()`
- Immutability practices: Creating new objects/arrays instead of mutating

---

## 2. React Fundamentals

### Core Concepts

- **Components**: Functional and Class components
- **JSX**: Syntax for writing HTML-like code in JavaScript
- **Props**: Passing data to components
- **State**: Using `useState` hook to manage component state
- **Hooks**: Understanding `useEffect`, `useContext`, and custom hooks
- **Lifecycle**: Component mounting, updating, and unmounting

### Example React Component

```javascript
import { useState } from "react";

function Counter() {
	const [count, setCount] = useState(0);

	return (
		<div>
			<p>Count: {count}</p>
			<button onClick={() => setCount(count + 1)}>Increment</button>
		</div>
	);
}

export default Counter;
```

### State Management Challenges

- Prop drilling (passing props through many levels)
- Shared state between sibling components
- Difficulty managing complex application state

---

## 3. State Management Concepts

### Why State Management?

- Applications grow complex with multiple components needing shared state
- Props passing becomes unwieldy
- Need for centralized, predictable state updates

### Centralized Store Pattern

- Single source of truth for application state
- Predictable state updates through actions
- Time-travel debugging capabilities

---

## 4. Redux Core Principles

### Three Core Principles

1. **Single Source of Truth**: One centralized store containing all state
2. **State is Read-Only**: State can only be changed by dispatching actions
3. **Changes are Made with Pure Functions**: Reducers are pure functions that take state and action, return new state

### Key Concepts

- **Store**: Object that holds the entire application state
- **Actions**: Plain objects describing what happened

  ```javascript
  { type: 'INCREMENT', payload: 1 }
  ```

- **Reducers**: Pure functions that return new state based on action

  ```javascript
  function counterReducer(state = 0, action) {
  	switch (action.type) {
  		case "INCREMENT":
  			return state + action.payload;
  		default:
  			return state;
  	}
  }
  ```

- **Dispatch**: Function to send actions to the store
- **Selectors**: Functions to extract data from store

---

## 5. Immutability

### Why Immutability Matters

- Ensures predictable state changes
- Enables efficient change detection
- Facilitates debugging and time-travel

### Immutable Patterns

```javascript
// Creating new arrays
const newArray = [...oldArray, newItem];
const filtered = array.filter((item) => item.id !== 5);

// Creating new objects
const newObject = { ...oldObject, name: "New Name" };
```

---

## 6. Middleware and Async Operations

### Middleware Concept

- Functions that intercept actions before they reach reducers
- Used for logging, async operations, and side effects

### Handling Async Operations

- API calls need to be handled outside of reducers
- Middleware or custom hooks for side effects
- Common patterns: Thunk, Saga, or custom middleware

---

## 7. Debugging and DevTools

### Redux DevTools

- Browser extension for inspecting state changes
- Time-travel debugging
- Action history replay

### Best Practices

- Understanding action flow
- Debugging state transitions
- Identifying state-related issues

---

## 8. Common Patterns and Anti-Patterns

### Good Practices

- Keep state normalized (flat structure)
- Make reducers pure functions
- Use selectors for accessing state
- Keep actions simple and descriptive

### Anti-Patterns to Avoid

- Mutating state directly
- Complex logic in reducers
- Dispatching multiple actions unnecessarily
- Not handling errors in async operations

---

## Self-Assessment Checklist

- [ ] Comfortable with ES6+ syntax
- [ ] Understand React hooks and functional components
- [ ] Familiar with handling async operations
- [ ] Know what immutability is and why it matters
- [ ] Understand the basic Redux flow: Action → Reducer → New State
- [ ] Aware of the problems Redux solves
- [ ] Familiar with destructuring and spread operator
- [ ] Can write pure functions

---

## Resources for Review

- **JavaScript**: MDN Web Docs
- **React**: Official React Documentation (react.dev)
- **Redux Concepts**: Redux Documentation
- **ES6 Features**: ES6 Learning Resources

---

## Next Steps

Once you're confident with these prerequisites, you'll be ready to learn:

1. Redux Toolkit setup and configuration
2. Creating slices with Redux Toolkit
3. Using Redux hooks (useSelector, useDispatch)
4. Handling async logic with createAsyncThunk
5. Best practices with Redux Toolkit
