# Redux Toolkit — Common Interview Questions and Answers

A focused set of Q&A to prep for interviews covering Redux, Redux Toolkit (RTK), React-Redux, and RTK Query. Includes concise explanations and small code snippets.

See also:

- 02.Redux Toolkit setup and configuration.md
- 03.Advanced Redux Toolkit Concepts.md
- 04.  Summery.md

---

## Core Concepts

1. What problem does Redux solve?

- Predictable global state container with a single source of truth, enabling time-travel debugging, testable state transitions, and consistent data flow via pure reducers.

2. When should you use Redux (or RTK) vs local React state?

- Use React state for local/ephemeral UI state. Use Redux/RTK when multiple parts of the app need shared state, complex updates, or cross-cutting concerns (caching, normalization, undo/redo). Avoid Redux for trivial or isolated state.

3. What does Redux Toolkit provide over “classic” Redux?

- Opinionated APIs that reduce boilerplate: `configureStore`, `createSlice`, `createAsyncThunk`, immer-powered immutable updates, sensible middleware (thunk + checks), and great TypeScript support.

4. What is a slice in RTK?

- A feature-focused module containing reducer logic and generated action creators.

```js
const slice = createSlice({
	name: "counter",
	initialState: { value: 0 },
	reducers: {
		increment: (s) => {
			s.value += 1;
		}, // safe: immer under the hood
	},
});
```

5. How does RTK enforce immutability while writing “mutable-looking” code?

- RTK uses Immer to wrap reducers, converting mutations into immutable updates under the hood.

---

## Store & Middleware

6. What does `configureStore` do?

- Creates the store with thunk, DevTools, and serializable/immutability checks by default; composes your slice reducers.

7. How to add custom middleware?

```js
const store = configureStore({
	reducer: rootReducer,
	middleware: (getDefault) => getDefault().concat(myMiddleware),
});
```

8. What are common non-serializable value warnings and how to fix them?

- Redux state/actions must be serializable. Avoid Promises, DOM nodes, class instances. If needed, disable or configure checks:

```js
configureStore({
	reducer,
	middleware: (getDefault) =>
		getDefault({
			serializableCheck: {
				ignoredActions: ["form/setNode"],
				ignoredPaths: ["form.nodeRef"],
			},
		}),
});
```

---

## Actions, Reducers, and Selectors

9. Difference between actions and reducers?

- Actions describe “what happened” (type + payload). Reducers are pure functions that compute the next state from the previous state and an action.

10. What are selectors and why use them?

- Functions to read data from state. They centralize query logic and can be memoized with Reselect, improving performance.

```js
import { createSelector } from "reselect";
const selectItems = (s) => s.cart.items;
export const selectTotal = createSelector([selectItems], (items) =>
	items.reduce((sum, i) => sum + i.price * i.qty, 0),
);
```

11. How to structure large apps with slices?

- Feature folder structure: each feature has its slice, thunks, selectors, and tests. Combine slices in `configureStore`.

---

## Async Logic

12. What is `createAsyncThunk` and how does it work?

- Wraps async logic and dispatches `pending/fulfilled/rejected` based on promise lifecycle.

```js
export const fetchUser = createAsyncThunk("user/fetch", async (id) => {
	const res = await fetch(`/api/users/${id}`);
	if (!res.ok) throw new Error("Network");
	return res.json();
});

const userSlice = createSlice({
	name: "user",
	initialState: { data: null, status: "idle", error: null },
	reducers: {},
	extraReducers: (b) => {
		b.addCase(fetchUser.pending, (s) => {
			s.status = "loading";
		})
			.addCase(fetchUser.fulfilled, (s, a) => {
				s.status = "succeeded";
				s.data = a.payload;
			})
			.addCase(fetchUser.rejected, (s, a) => {
				s.status = "failed";
				s.error = a.error.message;
			});
	},
});
```

13. How to cancel or ignore outdated async requests?

- Track `requestId` from `createAsyncThunk`, or rely on component scope to ignore late results. For fetch, use `AbortController`. RTK Query handles this automatically per subscription.

---

## Normalization & Entity Adapters

14. Why normalize state?

- Avoid deep nesting, simplify updates, enable efficient lookups, and easy de-duplication.

15. How does `createEntityAdapter` help?

```js
import { createSlice, createEntityAdapter } from "@reduxjs/toolkit";

const adapter = createEntityAdapter({
	selectId: (u) => u.id,
	sortComparer: (a, b) => a.name.localeCompare(b.name),
});
const slice = createSlice({
	name: "users",
	initialState: adapter.getInitialState(),
	reducers: {
		upsertMany: adapter.upsertMany,
		removeOne: adapter.removeOne,
	},
});
// selectors
export const selectors = adapter.getSelectors((s) => s.users);
```

---

## RTK Query (Server State)

16. What is RTK Query and when should you use it?

- A data fetching/caching layer for server state. Use it for APIs, caching, invalidation, polling, and automatic hook generation.

17. Basic RTK Query setup?

```js
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const api = createApi({
	reducerPath: "api",
	baseQuery: fetchBaseQuery({ baseUrl: "/api" }),
	endpoints: (b) => ({
		getUser: b.query({ query: (id) => `users/${id}` }),
		updateUser: b.mutation({
			query: (body) => ({ url: `users/${body.id}`, method: "PUT", body }),
		}),
	}),
});
export const { useGetUserQuery, useUpdateUserMutation } = api;
```

18. How does cache invalidation work in RTK Query?

- Tagging system: endpoints provide or invalidate tags so related queries refetch.

```js
endpoints: (b) => ({
	getUser: b.query({
		query: (id) => `users/${id}`,
		providesTags: (r, e, id) => [{ type: "User", id }],
	}),
	updateUser: b.mutation({
		query: (body) => ({ url: `users/${body.id}`, method: "PUT", body }),
		invalidatesTags: (r, e, { id }) => [{ type: "User", id }],
	}),
});
```

19. How to do optimistic updates with RTK Query?

- Use `onQueryStarted` to patch cache before response, revert on error.

```js
updateUser: b.mutation({
	query: (user) => ({ url: `users/${user.id}`, method: "PUT", body: user }),
	async onQueryStarted(user, { dispatch, queryFulfilled }) {
		const patch = dispatch(
			api.util.updateQueryData("getUser", user.id, (draft) =>
				Object.assign(draft, user),
			),
		);
		try {
			await queryFulfilled;
		} catch {
			patch.undo();
		}
	},
});
```

---

## Performance & Architecture

20. Common performance pitfalls with Redux?

- Overly broad `useSelector` causing re-renders; non-memoized derived data; storing non-serializable heavy objects; massive slices instead of feature splits.

21. How to minimize unnecessary re-renders?

- Use memoized selectors (`createSelector`), narrow selectors, `React.memo`, and avoid creating new references in mapState/selectors unless memoized.

22. Should you keep derived data in state?

- Prefer computing via selectors unless it’s expensive and stable; then cache/memoize.

---

## TypeScript

23. How to type `RootState` and `AppDispatch`?

```ts
export const store = configureStore({ reducer });
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

24. How to create typed hooks?

```ts
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

25. How to type `createAsyncThunk` payloads?

```ts
export const fetchUser = createAsyncThunk<User, string>(
	"user/fetch",
	async (id) => {
		const r = await fetch(`/api/users/${id}`);
		return r.json();
	},
);
```

---

## Testing & Debugging

26. How to test reducers?

- Call reducer with state + action and assert new state.

```js
expect(reducer({ value: 0 }, increment())).toEqual({ value: 1 });
```

27. How to test thunks?

- Mock network and assert dispatched actions with libraries like MSW or jest mocks.

28. How to debug Redux state changes?

- Use Redux DevTools: action timeline, state diffing, time travel.

---

## SSR, Persistence, and Side Effects

29. Does Redux work with SSR?

- Yes. Create a new store per request, prefetch data, and hydrate on the client.

30. How to persist Redux state?

- Use `redux-persist` or manual serialization. Be selective about which slices you persist.

31. Thunk vs Saga vs Observables?

- Thunk: simple async functions; Saga: generator-based orchestration; Observables: stream-based. RTK defaults to thunks; RTK Query replaces many thunk use cases for server state.

---

## Best Practices & Gotchas

32. Common mistakes to avoid:

- Storing non-serializable values; duplicating derived data; huge monolithic reducers; not normalizing lists; broad selectors causing re-renders.

33. How to organize files?

- Feature-based folders: `features/<name>/{slice.ts, selectors.ts, thunks.tsx, components/}`. Keep cross-links in an `api/` or `services/` layer for RTK Query.

34. How to migrate from classic Redux to RTK?

- Replace `createStore` with `configureStore`, reducers with `createSlice`, async logic with `createAsyncThunk` (or RTK Query for server state), and simplify action types.

---

## Quick References

- Setup & Basics: 02.Redux Toolkit setup and configuration.md
- Advanced & Patterns: 03.Advanced Redux Toolkit Concepts.md
- Summary/Cheat Sheet: 04. Summery.md
- Official Docs: https://redux-toolkit.js.org/
- Style Guide: https://redux.js.org/style-guide
