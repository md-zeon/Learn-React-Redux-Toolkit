# Redux Toolkit — Summary & Cheat Sheet

A concise, practical recap of Redux Toolkit essentials, with quick commands, patterns, and pointers to deeper docs you've built in this repo.

---

## What You Should Know

- Predictable global state with less boilerplate than classic Redux.
- Opinionated defaults: immer for immutable updates, good defaults for middleware and DevTools.
- Slices bundle actions + reducers; thunks simplify async logic; RTK Query (optional) streamlines server state.

---

## Quick Setup Recap

Install:

```bash
npm install @reduxjs/toolkit react-redux
```

Store:

```js
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./features/counter/counterSlice";

export const store = configureStore({
	reducer: { counter: counterReducer },
});
```

Provider:

```jsx
import { Provider } from "react-redux";
import { store } from "./store";

<Provider store={store}>
	<App />
</Provider>;
```

Slice:

```js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
	name: "counter",
	initialState: { value: 0 },
	reducers: {
		increment: (s) => {
			s.value += 1;
		},
		addBy: (s, a) => {
			s.value += a.payload;
		},
	},
});

export const { increment, addBy } = counterSlice.actions;
export default counterSlice.reducer;
```

Use in components:

```jsx
import { useSelector, useDispatch } from 'react-redux'
import { increment, addBy } from './features/counter/counterSlice'

const value = useSelector((s) => s.counter.value)
const dispatch = useDispatch()

<button onClick={() => dispatch(increment())}>+</button>
<button onClick={() => dispatch(addBy(5))}>+5</button>
```

See: 02.Redux Toolkit setup and configuration.md

---

## Async Basics with createAsyncThunk

```js
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

export const fetchById = createAsyncThunk("item/fetchById", async (id) => {
	const res = await fetch(`/api/items/${id}`);
	if (!res.ok) throw new Error("Network error");
	return res.json();
});

const slice = createSlice({
	name: "item",
	initialState: { data: null, status: "idle", error: null },
	reducers: {},
	extraReducers: (b) => {
		b.addCase(fetchById.pending, (s) => {
			s.status = "loading";
		})
			.addCase(fetchById.fulfilled, (s, a) => {
				s.status = "succeeded";
				s.data = a.payload;
			})
			.addCase(fetchById.rejected, (s, a) => {
				s.status = "failed";
				s.error = a.error.message;
			});
	},
});
```

See: 03.Advanced Redux Toolkit Concepts.md

---

## Core APIs at a Glance

- `configureStore()`: sets up store with sensible defaults (DevTools, thunk, serializable checks).
- `createSlice()`: generates slice reducer + action creators from case reducers.
- `createAsyncThunk()`: encapsulates async flow; dispatches pending/fulfilled/rejected.
- `createSelector()` (Reselect): memoize derived data from state.

---

## Patterns & Best Practices

- Keep state normalized: ids + entities; avoid deep nesting.
- Co-locate slice, selectors, and thunks in feature folders.
- Use immutable mutations (immer lets you write mutable-looking code safely).
- Derive data with selectors; keep state minimal (no duplicates of computable data).
- Use `builder.addCase` in `extraReducers` for async/thunk cases.

---

## Performance Tips

- Memoize expensive computations with `createSelector`.
- Split slices by feature; avoid one giant reducer.
- Use React component memoization (`React.memo`) where prop equality is stable.
- Prefer `useSelector` with narrowly scoped selectors.

---

## Testing Quick Notes

- Reducers: pure and easy to unit test.

```js
expect(reducer(undefined, { type: "unknown" })).toEqual({ value: 0 });
```

- Action creators: test payloads and shapes.
- Thunks: test side effects with mock fetch or MSW.

---

## Troubleshooting Checklist

- Actions not dispatched? Ensure `Provider` wraps your tree and you're using `useDispatch`.
- State not updating? Confirm slice key under `reducer` matches selectors.
- Async stuck at loading? Inspect `rejected` handler and network errors.
- Non-serializable values warning? Exclude with `serializableCheck.ignoredActions/ignoredPaths` or fix the source.

---

## RTK Query (Optional Next Level)

- Powerful data fetching & caching built into RTK.
- Generates hooks for queries and mutations.
- Eliminates manual `createAsyncThunk` + loading/error boilerplate for server state.

Docs: https://redux-toolkit.js.org/rtk-query/overview

---

## Resources & Cross-Links

- Setup: 02.Redux Toolkit setup and configuration.md
- Advanced: 03.Advanced Redux Toolkit Concepts.md
- Official docs: https://redux-toolkit.js.org/
- Style guide: https://redux.js.org/style-guide

---

## What’s Next

- Add RTK Query for API calls.
- Normalize entities and add selectors for derived views.
- Strengthen tests with MSW and Reselect-heavy scenarios.
- Consider TypeScript for safer, self-documenting state.
